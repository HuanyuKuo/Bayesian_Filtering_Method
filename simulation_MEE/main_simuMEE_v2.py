# -*- coding: utf-8 -*-
"""

June 20, 2020
#(finished) simulation of MEE

Created on Thu Jun 18 22:22:20 2020

@author: Ruby

simulation_MEE Microbial Experimental Evolution
"""

import sys
sys.path.insert(1, '../main_scripts/')
from myVariables import Constant, Global
import myConstant as mc
from matplotlib import pyplot as plt
import numpy as np

'''
==================================

Set Parameters for Simulations

==================================
'''

simu_NL = 1*10**4  # Totla number of lineage having data generated by this program
meanfitness = 0.0 # initial meanfitness
epsilon = mc.epsilon
T=10
NL_s = 200 # number of adaptive lineages

'''
==================================

Declare Class from MEE_Variable

==================================
'''
Rt = [10**6]*T
const = Constant(Rt, epsilon)
glob = Global(const)
current_timestep =0
glob.epsilon = epsilon

'''
=================================
Functions
=================================
'''
def Initialization(NL):
    Nc = glob.N/NL -1
    cell_num=[]
    for i in range(NL):
        cell_sample = 0
        while(cell_sample<1):
            cell_sample = int(np.random.exponential(scale=Nc))
        #cell_sample = int(np.random.exponential(scale=Nc)) +1
        cell_num.append(cell_sample)
    cell_num = np.asarray(cell_num)
    return cell_num

def Measurement(cell_num, t):
    glob.N = np.sum(cell_num)
    
    nb_n = 1/ glob.epsilon
    ratio = np.exp( np.log(glob.R)- np.log(glob.N) + np.log(glob.epsilon) )
    nb_p = np.exp(-np.log(1+ cell_num*ratio ))
    BC_read = np.zeros(shape=cell_num.shape)
    
    for idx in range(nb_p.size):
        p_ = nb_p[idx]
        BC_read[idx] = np.random.negative_binomial(nb_n, p_)
    return BC_read.astype(int)

def Assign_Selection_Coefficient(cell_num):
    
    idx = np.where(cell_num>100)[0][0:NL_s]
    #s_adaptive = []
    s_arr = np.zeros(shape=cell_num.shape)
    for i in range(NL_s):
        s = 0
        while(s<=0):
            s = np.random.normal(loc=0.4, scale=0.2)
        s_idx = idx[i]
        s_arr[s_idx] = s
    
    return s_arr, idx
    
def Transition(cell_num, s_arr):
    N_fix = np.sum(cell_num)
    cell_num2 = np.asarray([ round(glob.D*np.exp( (s-1*glob.meanfitness))*np.random.poisson(lam=n/glob.D)) for s,n in list(zip(s_arr,cell_num))] )
    cell_num2 = cell_num2/np.sum(cell_num2)*N_fix
    meanfitness = get_meanfitness(cell_num2, s_arr)
    return cell_num2, meanfitness

def get_meanfitness(cell_num, s_arr):
    simu_NL = len(s_arr)
    freq = cell_num *np.exp( - np.log(np.mean(cell_num)) - np.log(simu_NL))
    s_ave = np.sum(freq*s_arr)
    return s_ave

def plot_meanfitness(meanfitness, lineage_info):
    x= np.arange(0,np.size(meanfitness))
    plt.figure(figsize=(8,5.5))
    plt.plot(x, meanfitness,'o', color='grey')
    x = [x[2*i+1] for i in range(const.T-1)]
    y = [meanfitness[2*i+1] for i in range(const.T-1)]
    plt.plot(x,y, 'ko')
    plt.xlabel('cycle')
    plt.title('mean fitness (1/cycle)')
    plt.savefig('meanfitness_trajectory_'+lineage_info['lineage_name']+'.pdf', dpi=400)
def plot_DFE(s_arr,s_idx, lineage_info):
    #x= np.arange(0,np.size(meanfitness_arr))
    plt.figure(figsize=(8,5.5))
    s= s_arr[s_idx]
    plt.hist(s)
    plt.xlabel('selection (1/cycle)')
    plt.title('DFE')
    plt.savefig('DFE_'+lineage_info['lineage_name']+'.pdf', dpi=400)    
    
def plot_cell_Trajector(cell_num_arr, s_arr, lineage_info):
    cell_num_arr = cell_num_arr.T
    s_sort_idx = sorted(range(len(s_arr)), key=lambda k: s_arr[k], reverse=False)
    NL = len(s_arr)
    Nt = np.sum(cell_num_arr, axis=1)
    log10_total_numcell = np.log10(np.mean(cell_num_arr, axis = 1))+np.log10(NL)
    
    plt.figure(figsize=(8,5.5))
    colormap = plt.cm.YlOrRd(np.linspace(-1,1,101))
    x = np.arange(0, len(cell_num_arr))
    for idx in s_sort_idx[0:-1-NL_s]: # from small s to large s
        if idx%50==0:
            cellnum = cell_num_arr.T[idx] 
            cellnum = cellnum + (cellnum==0)*(0.01*Nt/glob.R) # avoid inf in log10
            log10_cellnum = np.log10(cellnum)
            log10freq = log10_cellnum - log10_total_numcell
            #s = np.max(0,np.max(100, int((1-s_arr[idx])*100)) )
            plt.plot(x, log10freq, color='grey' , linewidth=0.3)
    for idx in s_sort_idx[-1-NL_s:-1]:
        cellnum = cell_num_arr.T[idx] 
        cellnum = cellnum + (cellnum==0)*(0.01*Nt/glob.R) # avoid inf in log10
        log10_cellnum = np.log10(cellnum)
        log10freq = log10_cellnum - log10_total_numcell
        s = int(max(0,min(100, (s_arr[idx]*100))))
        plt.plot(x, log10freq, color=colormap[s] , linewidth=0.3)
    plt.xlabel('time point (1 t = 2 cycle)')
    plt.title('Log10  Cell Number Frequency Trajectory')
    plt.savefig('CellNum_Freq_'+lineage_info['lineage_name']+'.pdf', dpi =800)

def plot_barcodefreq_Trajector(bc_arr, s_arr, lineage_info):
    NL = len(s_arr)
    bc_arr = bc_arr.T
    s_sort_idx = sorted(range(len(s_arr)), key=lambda k: s_arr[k], reverse=False)
    log10_total_reads = np.log10(np.mean(bc_arr, axis = 1))+np.log10(NL)
    
    plt.figure(figsize=(8,5.5))
    colormap = plt.cm.YlOrRd(np.linspace(0,1,101))
    x = np.arange(0, len(bc_arr))
    for idx in s_sort_idx[0:-1-NL_s]: # from small s to large s
        if idx%50==0:
            bc_count = bc_arr.T[idx] 
            bc_count = bc_count + (bc_count==0)*(0.1) # avoid inf in log10
            log10_bc_count = np.log10(bc_count)
            log10freq = log10_bc_count - log10_total_reads
            #s = np.max(0,np.max(100, int((1-s_arr[idx])*100)) )
            plt.plot(x, log10freq, color='grey' , linewidth=0.3)
    for idx in s_sort_idx[-1-NL_s:-1]:
        bc_count = bc_arr.T[idx] 
        bc_count = bc_count + (bc_count==0)*(0.1) # avoid inf in log10
        log10_bc_count = np.log10(bc_count)
        log10freq = log10_bc_count - log10_total_reads
        s = int(max(0,min(100, (s_arr[idx]*100))))
        plt.plot(x, log10freq, color=colormap[s] , linewidth=0.3)
    plt.xlabel('time point (1 t = 2 cycle)')
    plt.title('Log10  Barcode Count Freq Trajectory')
    plt.savefig('Barcode_Freq_'+lineage_info['lineage_name']+'.pdf', dpi=800)


def run():
    
    t=glob.current_timepoint
    # Initialization t=0
    cell_num= Initialization(simu_NL)
    s_arr, s_idx = Assign_Selection_Coefficient(cell_num)
    glob.meanfitness = get_meanfitness(cell_num, s_arr)
    bc_read = Measurement(cell_num, 0)
    
    cell_num_save = [cell_num]
    meanfitness_save = [glob.meanfitness]
    bc_read_save = [bc_read]
    
    #measure every two transitions
    for t in range(1, const.T):
        for cycle in range(int(glob.C)):
            cell_num, glob.meanfitness = Transition(cell_num, s_arr)
            meanfitness_save.append(glob.meanfitness)
        cell_num_save.append(cell_num)
        bc_read = Measurement(cell_num, t)
        bc_read_save.append(bc_read)
        #glob.print_values()
    
    return bc_read_save, meanfitness_save, s_arr, cell_num_save, s_idx

def print_run(lineage_info):
    f = open('simuMEE_'+lineage_info['lineage_name']+'_information.txt','w')
    f.write('Number of Lineage={:d}\n'.format(simu_NL))
    f.write('Number of adaptive Lineage={:d}\n'.format(NL_s))
    f.write('Number of total cell={:d}\n'.format(int(glob.N)))
    f.write('total time point={:d}\n'.format(T))
    f.write('epsilon={:.1f}\n'.format(glob.epsilon))
    f.write('total reads={:0f}\n'.format(glob.R))
    f.write('DFE ' + lineage_info['DFE'] + '\n')
    f.write('diluiton ratio {:.0f}'.format(glob.D))
    f.close()
    
if __name__ == '__main__':
    
    lineage_info =  {'lineage_name': '20220213'}
    lineage_info['DFE']= 'Normal_dist'
    fname = 'simuMEE_'+lineage_info['lineage_name']
    
    '''
    ==================================
    Run
    ==================================
    '''
    '''
    bc_read_save, meanfitness_save, s_arr, cell_num_save, s_idx = run()
    print_run(lineage_info)
    bc_read = np.asarray(bc_read_save).T
    cell_num = np.asarray(cell_num_save).T
    
    np.savez(file=fname, cell_num=cell_num, bc_read=bc_read, meanfitness=meanfitness_save,  s_arr=s_arr)
    del s_arr, cell_num, bc_read, meanfitness_save
    '''
    '''
    ==================================
    Report
    ==================================
    '''
    
    load = np.load('./'+fname+'.npz')
    bc_read = load['bc_read']
    cell_num = load['cell_num']
    meanfitness = load['meanfitness']
    s_arr = load['s_arr']
    '''
    plot_meanfitness(meanfitness, lineage_info)
    plot_cell_Trajector(cell_num, s_arr, lineage_info)
    plot_DFE(s_arr,s_idx, lineage_info)
    plot_barcodefreq_Trajector(bc_read, s_arr, lineage_info)
    '''
    
    # Save barcode read as a txt file 
    f = open('./'+ 'Data_BarcodeCount_'+fname+'.txt','w')
    f.write('Barcode Index\t')
    cycles = [sum(const.Ct[0:i]) for i in range(len(const.Ct))]
    cycles = [str(c) for c in cycles]
    f.write('T=')
    f.write(' cycle\tT='.join(cycles)+' cycle\n')
    for i in range(len(bc_read)):
        reads = bc_read[i]
        reads = [str(r) for r in reads]
        f.write(str(i)+'\t')
        f.write(('\t').join(reads)+'\n')
    f.close()
    
    
    meanfitness_str = [str(m) for m in meanfitness]
    f= open('./'  + 'simulation_meanfitness_'+fname+'.txt','w')
    for t in range(len(meanfitness_str)):
        f.write(str(t)+' cycle\t')
        f.write(meanfitness_str[t]+'\n')
    f.close()
    
    f= open('./' 'simulation_selection_coefficient_'+ fname + '.txt', 'w')
    f.write('BCID\tselection_coefficient(1/cycle)\n')
    for i in range(len(s_arr)):
        f.write(str(i)+'\t'+str(s_arr[i])+'\n')
    f.close()
    